# Junior

### Устные вопросы (алгоритмы):
1) Какие деревья ты знаешь (структуры данных)?
2) Чем отличается сбалансированное дерево от несбалансированного?
3) Какие алгоритмы сортировки существуют, и какова их сложность в нотации Big O?
4) В чем заключаются различия между устойчивыми и неустойчивыми алгоритмами сортировки?

### Практические задачи (алгоритмы):

1) Задача "Квадраты отсортированного массива"
```
Задан целочисленный массив nums, отсортированный в порядке неубывания.
Реализовать функцию, которая возвращает массив квадратов этих чисел, отсортированный в порядке неубывания.
Требуется наилучшее решение по времени выполнения.

Пример 1
Ввод: nums = [-4,-1,0,3,10]
Вывод: [0,1,9,16,100]

Пример 2
Ввод: nums = [-7,-3,2,3,11]
Вывод: [4,9,9,49,121]
```
```go
func sortedSquares(nums []int) []int {
    
}
```

2) Задача "Наибольший общий префикс"
```
Реализовать функцию, которая находит самый длинный общий префикс среди элементов массива строк. 
Если такого префикса нет, программа должна вернуть пустую строку.

Пример 1
Ввод: strs = ["flower", "flow", "flight"]
Вывод: "fl"

Пример 2
Ввод: strs = ["dog", "racecar", "car"]
Вывод: ""

Ограничения:
1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] состоит только из строчных английских букв.
```
```go
func longestCommonPrefix(strs []string) string {
    
}
```

3) Задача "Пересечение двух массивов"
```
Даны два целочисленных массива nums1 и nums2, верните массив их пересечения. 
Каждый элемент в результате должен быть уникальным, и вы можете вернуть результат в любом порядке.
Требуется наилучшее решение по времени выполнения.

Пример 1
Ввод: nums1 = [1,2,2,1], nums2 = [2,2]
Вывод: [2]

Пример 2
Ввод: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Вывод: [9,4]
```
```go
func intersection(nums1 []int, nums2 []int) []int {

}
```

### Практические задачи (concurrency):
1) Задача "Асинхронное слияние каналов"

Реализовать функцию asyncMerge, которая будет производить асинхронное слияние каналов
```go
func main(){
ch1 := make(chan int, 10)
ch2 := make(chan int, 20)

    ch1 <- 1
    ch2 <- 2
    ch2 <- 4
    
    close(ch1)
    close(ch2)
    
    ch3 := asyncMerge[int](ch1, ch2)
    
    for val := range ch3 {
        fmt.Println(val)
    }
}

func asyncMerge[T any](chans ...chan T)chan T {
    return nil
}
```

2) Задача "Конкурентный подсчет слов"

Реализовать асинхронный подсчет количества слов во всех файлах

На вход получаем массив строк, который содержит названия файлов
Каждый файл содержит простой текст, где слова разделены пробелами

Ожидаемый вывод: "total words: 15"

```go
func main(){
    files = []string{"file1.txt", "file2.txt", "file3.txt"}
}
```

3) Задача "Оптимизация запросов к внешнему сервису"

Необходимо ускорить выполнение программы, учитывая следующие условия:
- Время ответа сервиса может достигать 3 секунды
- Одновременно сервис может обрабатывать не более 300 клиентских соединений
Нужно ускорить этот код

```go
type User struct {
    Id         int    `json:"id"`
    Name       string `json:"name"`
    SpentMoney int    `json:"spentMoney"`
}

const (
    url      = "https://www.wildberries.ru/getPurchasesByID?id=%d"
    reqCount = 10_000_000
)

func main() {
    maxSpentMoney := 0
    for id := 0; id < reqCount; id++ {
        response, err := http.Get(fmt.Sprintf(url, id))
        if err != nil {
            log.Fatal(err)
        }

        buf, err := io.ReadAll(response.Body)
        if err != nil {
            log.Fatal(err)
        }

        var user User

        err = json.Unmarshal(buf, &response)
        if err != nil {
            log.Fatal(err)
        }

        if user.SpentMoney > maxSpentMoney {
            maxSpentMoney = user.SpentMoney
        }
    }

    fmt.Println(maxSpentMoney)
}
```
